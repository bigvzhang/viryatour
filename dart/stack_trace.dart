import 'dart:async';
import 'dart:io';
//import 'dart:mirrors';

import 'package:stack_trace/stack_trace.dart';

void main(List<String> args) {
  	String cmd = "";
	for(String arg in args){ 
		if(arg == "std"){
			cmd=arg;
		}else if(arg == "ext"){
			cmd=arg;
		}else{
			print("invald argument - $arg");
			exit(1); // require dart:io
		}
	}
	if     (cmd == "std")  { parseStackTrace(StackTrace.current.toString()); }
	else if(cmd == "ext")  { Chain.capture(() { scheduleAsync(); }); }
	else                   { parseStackTrace(StackTrace.current.toString()); } // as std
}

// #1      Foo._bar (file:///home/nweiz/code/stuff.dart:42:21)
// #1      Foo._bar (file:///home/nweiz/code/stuff.dart:42)
// #1      Foo._bar (file:///home/nweiz/code/stuff.dart)
final _vmFrame = RegExp(r'^#\d+\s+(\S.*) \((.+?)((?::\d+){0,2})\)$');
/// A regular expression that matches asynchronous member names generated by the VM.
final _asyncBody = RegExp(r'<(<anonymous closure>|[^>]+)_async_body>');

 /// Parses a string representation of a Dart VM stack frame.
void parseStackTrace(String frames) {
  void parse_(String frame)  {
        if (frame.length == 0) { return; }
        // The VM sometimes folds multiple stack frames together and replaces
        // them with "...".
        if (frame == '...') {
          //return Frame(Uri(), null, null, '...');
		  print("==1"+frame);
        }

        var match = _vmFrame.firstMatch(frame);
        if (match == null) {print("==2"+frame); return;} //return UnparsedFrame(frame);

        // Get the pieces out of the regexp match. Function, URI and line should
        // always be found. The column is optional.
        var member = match[1]!
            .replaceAll(_asyncBody, '<async>')
            .replaceAll('<anonymous closure>', '<fn>');
        var uri = match[2]!.startsWith('<data:')
            ? Uri.dataFromString('')
            : Uri.parse(match[2]!);

        var lineAndColumn = match[3]!.split(':');
        var line =
            lineAndColumn.length > 1 ? int.parse(lineAndColumn[1]) : null;
        var column =
            lineAndColumn.length > 2 ? int.parse(lineAndColumn[2]) : null;
		print("uri:${uri} line:${line} column:${column} member:${member}");
        //return Frame(uri, line, column, member);
      }
	var frames_ = frames.split("\n");
	for(var frame in frames_){ parse_(frame); }
}

void scheduleAsync() {
  //print(StackTrace.current.runtimeType);
  //print(Trace.current().runtimeType);
  //print(reflect(StackTrace.current).type.reflectedType.toString());
  //print(reflect(Trace.current()).type.reflectedType.toString());
  //print(StackTrace.current);
  //print(Trace.current());
  new Future.delayed(new Duration(seconds: 1))
      .then((_) => runAsync());
}
void runAsync() {
  throw 'oh no!';
}
